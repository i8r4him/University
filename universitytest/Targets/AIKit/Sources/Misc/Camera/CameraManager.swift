//
//  CameraManager.swift
//  AIKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/aikit/ai-vision-example
//

import AVFoundation
import AnalyticsKit
import SharedKit
import SwiftUI

// The View Name for Analytics Capture
private let viewName = "CameraManager"

// this class conforms to ObservableObject to make it easier to use with future Combine code
class CameraManager: ObservableObject {

	// Represents the camera's status
	enum Status {
		case configured
		case unconfigured
		case unauthorized
		case failed
	}

	/// Observes changes in the camera's status
	@Published var status = Status.unconfigured

	/// AVCaptureSession manages the camera settings and data flow between capture inputs and outputs.
	/// It can connect one or more inputs to one or more outputs
	let session = AVCaptureSession()

	/// AVCapturePhotoOutput for capturing photos
	let photoOutput = AVCapturePhotoOutput()

	/// AVCaptureDeviceInput for handling video input from the camera
	/// Basically provides a bridge from the device to the AVCaptureSession
	var videoDeviceInput: AVCaptureDeviceInput?

	/// Serial queue to ensure thread safety when working with the camera
	private let sessionQueue = DispatchQueue(label: "com.demo.sessionQueue")

	/// current camera position (front or back)
	var position: AVCaptureDevice.Position = .back

	@Published var capturedImage: UIImage? = nil

	@Published var orientation: UIDeviceOrientation

	private var cameraDelegate: CameraDelegate?

	init() {
		self.orientation = UIDevice.current.orientation
		setupOrientationObserver()
	}

	private func setupOrientationObserver() {
		NotificationCenter.default.addObserver(
			self,
			selector: #selector(updateOrientation),
			name: UIDevice.orientationDidChangeNotification,
			object: nil
		)
	}

	@objc private func updateOrientation() {
		DispatchQueue.main.async { [weak self] in
			self?.orientation = UIDevice.current.orientation
		}
	}

	// Method to configure the camera capture session
	func configureCaptureSession() {
		sessionQueue.async { [weak self] in
			guard let self, self.status == .unconfigured else { return }

			// Begin session configuration
			self.session.beginConfiguration()

			// Set session preset for high-quality photo capture
			self.session.sessionPreset = .photo

			// Add video input from the device's camera
			self.setupVideoInput()

			// Add the photo output configuration
			self.setupPhotoOutput()

			// Commit session configuration
			self.session.commitConfiguration()

			// Start capturing if everything is configured correctly
			self.startCapturing()
		}
	}

	// Method to set up video input from the camera
	private func setupVideoInput() {
		do {
			// Get the default wide-angle camera for video capture
			// AVCaptureDevice is a representation of the hardware device to use
			let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: position)

			guard let camera else {
				print("[CAMERA MANAGER]: Video device is unavailable.")
				Analytics.capture(
					.error, id: "setup_video_input", longDescription: "Error: Camera is nil", source: .aikit,
					fromView: viewName)
				status = .unconfigured
				session.commitConfiguration()
				return
			}

			// Create an AVCaptureDeviceInput from the camera
			let videoInput = try AVCaptureDeviceInput(device: camera)

			// Add video input to the session if possible
			if session.canAddInput(videoInput) {
				session.addInput(videoInput)
				videoDeviceInput = videoInput
				status = .configured
				print("[CAMERA MANAGER]: Camera Configured")
				Analytics.capture(.info, id: "setup_video_input_success", source: .aikit, fromView: viewName)
			} else {
				print("[CAMERA MANAGER]: Couldn't add video device input to the session.")
				Analytics.capture(
					.error, id: "setup_video_input",
					longDescription: "Error: Couldn't add video device input to the session", source: .aikit,
					fromView: viewName)
				status = .unconfigured
				session.commitConfiguration()
				return
			}
		} catch {
			print("[CAMERA MANAGER]: Couldn't create video device input: \(error)")
			Analytics.capture(
				.error, id: "setup_video_input",
				longDescription: "Catch-All Error: \(error.localizedDescription)", source: .aikit,
				fromView: viewName)
			status = .failed
			session.commitConfiguration()
			return
		}
	}

	// Method to configure the photo output settings
	private func setupPhotoOutput() {
		if session.canAddOutput(photoOutput) {
			// Add the photo output to the session
			session.addOutput(photoOutput)

			session.sessionPreset = .photo

			photoOutput.connections.first?.videoRotationAngle = Self.convertOrientationToVideoRotationAngle(
				UIDevice.current.orientation)

			// Update the status to indicate successful configuration
			status = .configured
		} else {
			print("[CAMERA MANAGER]: Could not add photo output to the session")
			Analytics.capture(
				.error, id: "setup_photo_output",
				longDescription: "Error: Could not add photo output to the session", source: .aikit,
				fromView: viewName)
			// Set an error status and return
			status = .failed
			session.commitConfiguration()
			return
		}
	}

	// Method to start capturing
	private func startCapturing() {
		if status == .configured {
			// Start running the capture session
			self.session.startRunning()
		} else if status == .unconfigured || status == .unauthorized {
			DispatchQueue.main.async {
				showInAppNotification(
					.error,
					content: .init(
						title: "Camera Configuration Failed",
						message: "Camera not available or missing permissions"))
				Analytics.capture(
					.error, id: "start_capturing",
					longDescription: "Error: Camera not available or missing permissions", source: .aikit,
					fromView: viewName)
			}
		}
	}

	// Method to stop capturing
	func stopCapturing() {
		// Ensure thread safety using `sessionQueue`.
		sessionQueue.async { [weak self] in
			guard let self else { return }

			// Check if the capture session is currently running.
			if self.session.isRunning {
				// stops the capture session and any associated device inputs.
				self.session.stopRunning()
			}
		}
	}

	// Used during camera flip (front / back)
	func resetVideoInput() {
		// Check if a current video input exists
		guard let videoDeviceInput else { return }

		// Remove the current video input
		session.removeInput(videoDeviceInput)

		// Set up the new video input
		setupVideoInput()
	}

	func captureImage() {
		sessionQueue.async { [weak self] in
			guard let self else { return }

			// Configure photo capture settings
			var photoSettings = AVCapturePhotoSettings()

			// Capture HEIC photos when supported
			if photoOutput.availablePhotoCodecTypes.contains(.hevc) {
				photoSettings = AVCapturePhotoSettings(format: [AVVideoCodecKey: AVVideoCodecType.hevc])
			}

			// Specify photo quality and preview format
			if let previewPhotoPixelFormatType = photoSettings.availablePreviewPhotoPixelFormatTypes.first {
				photoSettings.previewPhotoFormat = [
					kCVPixelBufferPixelFormatTypeKey as String: previewPhotoPixelFormatType
				]
			}

			photoSettings.photoQualityPrioritization = .balanced

			let videoConnectionRotationAngle: CGFloat = Self.convertOrientationToVideoRotationAngle(
				UIDevice.current.orientation)

			if let videoConnection = photoOutput.connection(with: .video),
				videoConnection.isVideoRotationAngleSupported(videoConnectionRotationAngle)
			{
				videoConnection.videoRotationAngle = videoConnectionRotationAngle
			}

			cameraDelegate = CameraDelegate { [weak self] image in
				self?.capturedImage = image
			}

			if let cameraDelegate {
				// Capture the photo with delegate
				self.photoOutput.capturePhoto(with: photoSettings, delegate: cameraDelegate)
			} else {
				Analytics.capture(
					.error, id: "capture_image",
					longDescription: "Error: Could not capture photo with delegate, delegate is nil",
					source: .aikit,
					fromView: viewName)
			}
		}
	}

	/// Takes orientation as an input and returns the correct video rotation angle for the picture to be taken in
	public static func convertOrientationToVideoRotationAngle(_ orientation: UIDeviceOrientation) -> CGFloat {
		switch orientation {
			case .portrait:
				return 90
			case .portraitUpsideDown:
				return 270
			case .landscapeLeft:
				return 0
			case .landscapeRight:
				return 180
			default:
				return 0
		}
	}
}
